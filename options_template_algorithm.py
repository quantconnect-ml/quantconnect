# Used only on Local
from qc_interface import QCAlgorithm, Resolution


# My Package imports
from qc_utils import SlidingWindow
from position_tracker import PositionTracker
# Std lib imports
from datetime import datetime, timedelta
from decimal import Decimal


class OptionsTemplateAlgorithm(QCAlgorithm):

    class OptionType:
        PUT = 0
        CALL = 1

    class SignalType:
        NONE = 0
        OPEN = 1
        CLOSE = 2

    class TradePosition:
        SHORT = 0
        LONG = 1

        @classmethod
        # gets the quantity to long or short i.e qty = 1, position = Short => -1
        def GetQty(cls, qty, position):
            return qty if position == cls.LONG else -qty

    ############## Helper/Util methods

    def ConvertDailyResolution(self, data_handler):
        """
        Options can only execute at minute intervals This function converts the
        data_handler to exectue at daily intervals
        :param data_handler: Type = fn(slice)
        :return: Type = fn(slice)
        """

        class DailyExecutor(object):
            # qc_instance in the instanceof qc_algorithm
            def __init__(self, qc_instance, handler):
                self.last_date = None # last date handler was called
                self.handler = handler
                self.first_call = True # flag to check first time __call__ is called
                self.qc = qc_instance

            def __call__(self, slice):
                if self.first_call:
                    self.handler(slice)
                    self.last_date = self.qc.Time
                    self.first_call = False
                time_diff = self.qc.Time - self.last_date
                if time_diff.days >= 1:
                    # need >= 1 as may be weekend gap
                    self.handler(slice)
                    assert self.last_date is not self.qc.Time, "Time object is mutated"
                    self.last_date = self.qc.Time

        return DailyExecutor(self, data_handler)

    ########## Order Contruction/ Trade Execution

    @classmethod
    def ConstructPosition(cls, option_chain, signal, curr_position,  qty=1):
        """
        Ensure dependencies are only on args to make easy testing
        Obtains the contracts to open an iron condor in direction of trade_position
        :param signal: Signal generated by GetSignal
        :param option_chain: OptionChain object
        :param curr_position: The position_tracker object for this strategy
        :return: [(Option, qty)]
        """
        calls = []
        puts = []
        for o in option_chain:
            if o.Right == cls.OptionType.CALL:
                calls.append(o)
            elif o.Right == cls.OptionType.PUT:
                puts.append(o)

        if not calls or not puts:
            self.Debug("Cannot create Position. Not enough options in Chain")
            return []
        # sort the calls and puts by (expiry, strike)
        calls = sorted(calls, key=lambda x: (x.Expiry, x.Strike))
        puts = sorted(puts, key=lambda x: (x.Expiry, x.Strike))

        underlying_price = calls[0].UnderlyingLastPrice

        raise NotImplementedError


    def EnterPosition(self, slice, signal):
        """
        Open a position in the portfolio. Uses Market Orders
        :param slice: slice object from onData
        """
        chain = None
        for o in slice.OptionChains:
            if o.Key == self.option.Symbol:
                chain = o.Value
                break
        if not chain:
            self.Debug("Option Chain should not be None in OpenPosition")
            return

        orders = self.ConstructPosition(chain, signal, self.position_tracker, qty=1)
        # make the orders and update position tracker
        self.Debug("Making Market Orders to Open {}".format(orders))
        for option, qty in orders:
            self.MarketOrder(option.Symbol, qty)
            self.position_tracker.UpdatePositon(option.Symbol, qty)
        # set the current expiry date of position held. Assumes all positions have same expiry
        if orders:
            self.curr_expiry = orders[0][0].Expiry
            self.Debug("Opened on {}, To Close on {}".format(self.Time, self.curr_expiry))
        return

    ############ Signal Generation

    @classmethod
    def GetSignal(cls, slice, curr_positions):
        '''
        Ensure dependencies only on args to make testing easy
        Function to generate the entry signal.
        OPEN signal when no positions held
        CLOSE signal when expiry date reached
        NONE in all other cases
        slice: slice object from OnData
        :return: Returns a value which is used by Position object
        '''
        signal = cls.SignalType.NONE
        raise NotImplementedError

    ############## Initializers

    # used for setup in intialize to setup algo specific parameters
    # configure algorithm, setup positions/instruments
    # only called once in Initialize
    def InitPreWarmUp(self):
        self.position_tracker = PositionTracker()
        self.symbol = "SPY"
        self.option = self.AddOption(self.symbol, Resolution.Minute)
        self.option.SetFilter(-20, 20, timedelta(0), timedelta(30))
        self.equity = self.AddEquity(self.symbol, Resolution.Minute)
        self.lookback = 14 # 14 day lookback period
        self.sliding_window = SlidingWindow(self.lookback)
        self.SetWarmUp(self.lookback)
        raise NotImplementedError # add other config variables

    # additional setup after warm up period
    # only called once
    def InitPostWarmUp(self):
        return

    def Initialize(self):
        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm.
        All algorithms must initialized.'''

        # make sure  the start and end dates are tradeable dates or an exception occurs
        self.SetStartDate(2015, 10, 5)  # Set Start Date
        self.SetEndDate(2015, 12, 31)  # Set End Date
        self.SetCash(100000)  # Set Strategy Cash
        self.InitPreWarmUp()
        # used to detect transition from warming up to warmed uo
        self.warmed_up = False

        # datetime obj must be the same as the StartDate in SetStartDate
        self.OnDataHandler = self.ConvertDailyResolution(self.DailyResolutionDataHandler)

    ############# Data Handlers
    # function to be converted by ConvertDailyResolution
    # Handles data at the open of each trading day
    def DailyResolutionDataHandler(self, slice):
        bar = slice[self.symbol]
        mid = Decimal(bar.Open + bar.Close) / Decimal(2.0)
        self.sliding_window.update(float(mid))
        if not self.warmed_up and not self.IsWarmingUp:
            # just finished warming up
            self.warmed_up = True
            self.InitPostWarmUp()
        if self.warmed_up and self.sliding_window.get_std():
            signal = self.GetSignal(slice)
            self.EnterPosition(slice, signal)


    def OnData(self, slice):
        '''
        Each new data point will be pumped in here.

        :param slice: Slice object keyed by symbol containing the stock data
        '''
        self.OnDataHandler(slice)


